{"version":3,"sources":["Components/Cube/Cube.js","Components/RubikCube/hooks.js","Components/RubikCube/useRotation.js","Components/RubikCube/useDrag.js","Components/RubikCube/useHistory.js","Components/RubikCube/RubikCube.js","Components/Ligths/Lights.js","Components/World/World.js","Components/Environment/Environment.js","App.js","serviceWorker.js","index.js"],"names":["Cube","forwardRef","ref","position","textures","useLoader","TextureLoader","mesh","useRef","materials","useState","x","y","z","faces","push","map","f","i","attachArray","color","metalness","roughness","clearcoat","reflectivity","Object","values","args","maxKey","v","absComponent","number","Math","abs","maxIndex","indexOf","max","apply","keys","randomNum","min","floor","random","findDirection","cubeFaceClicked","rubikCubeSide","axisDisplaced","vectorDragged","previousDragged","direction","foundDirection","current","console","log","initialState","initialCubeClicked","finalCube","rotateAxis","reducer","state","action","type","useRotation","useReducer","dispatch","useEffect","useDrag","onStart","onDrag","onEnd","blockControls","active","setActive","activeRef","down","useCallback","e","stopPropagation","target","setPointerCapture","pointerId","up","releasePointerCapture","move","onPointerDown","onPointerUp","onPointerMove","historyReducer","past","present","future","newPresent","length","previous","slice","next","newFuture","RubikCube","blockRubikCubeRotation","onShuffle","onUndo","onRedo","onSolve","initialPresent","React","canUndo","canRedo","undo","redo","set","reset","useHistory","allCubes","setAllCubes","controlRotation","setControlRotation","movementQueue","setMovementQueue","rubikCube","pivot","assistCube","j","k","key","activeDrag","faceClicked","intersections","point","sign","PI","visualMove","bindDrag","rotation","updateMatrixWorld","forEach","cube","round","children","getWorldPosition","THREE","applyMatrix4","matrixWorld","useFrame","movements","movement","props","val","concat","reverse","name","Lights","skyColor","groundColor","intensity","World","useThree","scene","gl","CubeTextureLoader","texture","useLayoutEffect","encoding","oldBg","background","oldEnv","environment","dispose","Environment","camera","useResource","WebGLCubeRenderTarget","cubeRenderTarget","update","visible","attach","envMap","opacity","transparent","extend","OrbitControls","CameraControls","rotate","domElement","controls","enableZoom","enableRotate","enableDamping","dampingFactor","maxDistance","minDistance","enablePan","App","clickOnCube","setClickOnCube","shuffleRef","undoRef","redoRef","solveRef","className","onClick","Canvas","shadowMap","fallback","callback","value","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.e0c0d534.chunk.js","sourcesContent":["import React, {forwardRef, useEffect, useRef, useState} from 'react'\r\nimport {useLoader} from 'react-three-fiber'\r\nimport { BackSide, TextureLoader } from 'three'\r\n\r\n\r\n\r\n\r\nconst Cube = forwardRef(({position}, ref) => {\r\n\r\n    const textures = useLoader(TextureLoader, \r\n      [\r\n      './Background/orangeTexture.png',\r\n      './Background/redTexture.png',\r\n      './Background/whiteTexture.png',\r\n      './Background/yellowTexture.png',\r\n      './Background/greenTexture.png', \r\n      './Background/blueTexture.png'\r\n    ])\r\n    const mesh = useRef()\r\n    const materials = []\r\n    const [faces] = useState([ //Face textures depending on position\r\n        position.x === 1 ? textures[0] : null, \r\n        position.x === -1 ? textures[1] : null, \r\n        position.y === 1 ? textures[2] : null, \r\n        position.y === -1 ? textures[3] : null, \r\n        position.z === 1 ? textures[4] : null, \r\n        position.z === -1 ? textures[5] : null\r\n    ])\r\n\r\n    materials.push(faces.map((f, i)=> {\r\n      return (\r\n        <meshStandardMaterial\r\n          attachArray=\"material\"\r\n          map={f}\r\n          color={f ? null : 'black'}\r\n          metalness={0}\r\n          roughness={0}\r\n          clearcoat={1}\r\n          reflectivity={1}\r\n        />\r\n      );\r\n    }))\r\n    \r\n    \r\n    return (\r\n      <group ref={ref} position={Object.values(position)} >\r\n        <mesh ref={mesh}>\r\n          <boxBufferGeometry args={[1, 1, 1]}/>\r\n          {materials}\r\n        </mesh>\r\n      </group>\r\n    );\r\n}\r\n)\r\n\r\nexport default Cube","//Returns the corresponding key to the maximum value in a object wich values are numbers\r\nexport const maxKey = (v) => {\r\n  let absComponent = Object.values(v).map(number => Math.abs(number))\r\n  let maxIndex = absComponent.indexOf(Math.max.apply(Math, absComponent))\r\n\r\n  return Object.keys(v)[maxIndex];\r\n}\r\n\r\nexport const randomNum = (min, max) => {\r\n  return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\n//Esta funcion devuelve el array de la diferencia entre dos arrays de objetos\r\n function splicedRubik(array1, array2){\r\n    function comparer(otherArray){\r\n      return (current) =>{\r\n        return otherArray.filter((other) =>{\r\n          return other.key === current.key\r\n        }).length === 0;\r\n      }\r\n    }\r\n    var onlyInA = array1.filter(comparer(array2));\r\n    var onlyInB = array2.filter(comparer(array1));\r\n\r\n    return onlyInA.concat(onlyInB)\r\n  }","import React, { useEffect, useReducer, useRef } from 'react'\r\nimport { MeshToonMaterial } from 'three'\r\nimport { maxKey } from './hooks.js'\r\n\r\nfunction findDirection(cubeFaceClicked, rubikCubeSide, axisDisplaced, vectorDragged, previousDragged, direction){\r\n  //Using the provided data find the direction the rubikcube must rotate\r\n  //Direction need to be rectified in some situations in order to be intuitive for the user\r\n  let foundDirection = (previousDragged.current \r\n                  ?  vectorDragged[axisDisplaced] - previousDragged.current[axisDisplaced] \r\n                  : vectorDragged[axisDisplaced])\r\n                                              >= 0 \r\n                                                ? 1 \r\n                                                : -1                         \r\n  if (\r\n    (cubeFaceClicked == \"z\" && axisDisplaced == \"y\") ||\r\n    (cubeFaceClicked == \"x\" && axisDisplaced == \"y\") ||\r\n    (cubeFaceClicked == \"y\" && axisDisplaced == \"x\")\r\n  )\r\n    foundDirection *= -1;\r\n  if (\r\n    (cubeFaceClicked == \"x\" && rubikCubeSide === 1) ||\r\n    (cubeFaceClicked == \"y\" && rubikCubeSide === -1) ||\r\n    (cubeFaceClicked == \"z\" && rubikCubeSide === -1)\r\n  )\r\n    foundDirection *= -1;\r\n    console.log(foundDirection)\r\n  return foundDirection\r\n}\r\n\r\nconst initialState = {\r\n  cubeFaceClicked: null,\r\n  initialCubeClicked: null,\r\n  rubikCubeSide: null,\r\n  finalCube: null,\r\n  rotateAxis: null,\r\n  direction: null\r\n};\r\n\r\nconst reducer = (state, action) => {\r\n  switch (action.type){\r\n    case 'start_movement_point':\r\n      return {cubeFaceClicked: action.cubeFaceClicked, initialCubeClicked: action.initialCubeClicked, rubikCubeSide: action.rubikCubeSide, finalCube: null}\r\n    case 'trace_movement_destination':\r\n      return {...state, finalCube: action.finalCube}\r\n    case 'rotate_movement':\r\n      return {...state, rotateAxis: action.rotateAxis, direction: action.direction}\r\n    case 'auto_rotate':\r\n      return {...state, initialCubeClicked: action.initialCubeClicked, rotateAxis: action.rotateAxis, direction: action.direction}\r\n    case 'finish_movement':\r\n      return {initialState}\r\n    default:\r\n      return null\r\n  }\r\n}\r\n\r\nconst useRotation = () => {\r\n  const [\r\n    {\r\n      cubeFaceClicked,\r\n      initialCubeClicked,\r\n      rubikCubeSide,\r\n      finalCube,\r\n      rotateAxis,\r\n      direction,\r\n    },\r\n    dispatch,\r\n  ] = useReducer(reducer, initialState);\r\n  \r\n  const previousDragged = useRef()\r\n\r\n  useEffect(()=> {\r\n    //Logic to find rotation axis: cubeFaceClicked stores the face of the cube that has been clicked. \r\n    // axisDisplaced stores the axis that had the biggest displacement when dragging the cube. \r\n    // Using both values, search in the axisRotationCorrespondance table, to retrieve the axis to be rotated.\r\n    if(initialCubeClicked && finalCube){\r\n      let vectorDragged = {\r\n        x: finalCube.x - initialCubeClicked.x,\r\n        y: finalCube.y - initialCubeClicked.y,\r\n        z: finalCube.z - initialCubeClicked.z,\r\n      };\r\n      \r\n      const axisDisplaced = maxKey(vectorDragged);\r\n      const axisRotationCorrespondance = {\r\n        x: { y: \"z\", z: \"y\" },\r\n        y: { x: \"z\", z: \"x\" },\r\n        z: { x: \"y\", y: \"x\" },\r\n      };\r\n      if(Math.abs(vectorDragged[axisDisplaced]) > 0.2 ){ //0.2 is the minimum displacement on any axis required to start a movement\r\n      //rotate the cubes using the calculated direction and rotating only the axis retrieved at the start of the movement \r\n      //TODO: axisDisplaced can change its value if the mouse pointer changes the direction while dragging, save and keep the initial value like rotateAxis\r\n      \r\n      dispatch({\r\n        type: \"rotate_movement\",\r\n        rotateAxis: rotateAxis ? rotateAxis : axisRotationCorrespondance[cubeFaceClicked][axisDisplaced],\r\n        direction: findDirection(\r\n          cubeFaceClicked ,\r\n          rubikCubeSide,\r\n          axisDisplaced,\r\n          vectorDragged,\r\n          previousDragged,\r\n          direction\r\n        ),\r\n      });\r\n      previousDragged.current = vectorDragged\r\n      } \r\n    }\r\n  },[finalCube])\r\n\r\n  useEffect(()=> {\r\n    if(!rotateAxis){\r\n      previousDragged.current = null\r\n    }\r\n  },[rotateAxis])\r\n\r\n  return [rotateAxis, initialCubeClicked, direction, dispatch]\r\n\r\n}\r\n\r\nexport default useRotation","import React, {useState, useRef, useEffect, useCallback} from 'react'\r\n\r\nconst useDrag = (onStart, onDrag, onEnd, blockControls) => {\r\n  const [active, setActive] = useState(false);\r\n  const activeRef = useRef();\r\n  const down = useCallback(\r\n    (e) => (\r\n      setActive(true),\r\n      blockControls(true),\r\n      e.stopPropagation(),\r\n      onStart && onStart(e),\r\n      e.target.setPointerCapture(e.pointerId),\r\n      console.log(e.pointerId)\r\n    ),\r\n    [onStart, blockControls]\r\n  );\r\n  const up = useCallback(\r\n    (e) => (\r\n      setActive(false),\r\n      blockControls(false),\r\n      e.target.releasePointerCapture(e.pointerId),\r\n      onEnd && onEnd(e)\r\n    ),\r\n    [onEnd, blockControls]\r\n  );\r\n  const move = useCallback(\r\n    (e) =>\r\n      activeRef.current &&\r\n      (e.stopPropagation(), onDrag(e)),\r\n    [onDrag]\r\n  );\r\n  useEffect(() => void (activeRef.current = active));\r\n  return [active, { onPointerDown: down, onPointerUp: up, onPointerMove: move }];\r\n}\r\n\r\nexport default useDrag","import React, {useReducer} from 'react'\r\n\r\nconst UNDO = \"UNDO\";\r\nconst REDO = \"REDO\";\r\nconst SET = \"SET\";\r\nconst RESET = \"RESET\";\r\n\r\nfunction historyReducer(state, action) {\r\n  const { past, present, future } = state;\r\n  const { type, newPresent } = action;\r\n\r\n  switch (action.type) {\r\n    case UNDO: {\r\n      if (past.length === 0) return state;\r\n      const previous = past[past.length - 1];\r\n      const newPast = past.slice(0, past.length - 1);\r\n      return {\r\n        past: newPast,\r\n        present: previous,\r\n        future: [present, ...future],\r\n      };\r\n    }\r\n\r\n    case REDO: {\r\n      if (future.length === 0) return state;\r\n      const next = future[0];\r\n      const newFuture = future.slice(1);\r\n      return {\r\n        past: [...past, present],\r\n        present: next,\r\n        future: newFuture,\r\n      };\r\n    }\r\n\r\n    case SET: {\r\n      if (newPresent === present) return state;\r\n      return {\r\n        past: [...past, present],\r\n        present: newPresent,\r\n        future: [],\r\n      };\r\n    }\r\n\r\n    case RESET: {\r\n      return {\r\n        past: [],\r\n        present: newPresent,\r\n        future: [],\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nexport default function useHistory(initialPresent) {\r\n  const [state, dispatch] = React.useReducer(historyReducer, {\r\n    past: [],\r\n    present: initialPresent,\r\n    future: [],\r\n  });\r\n\r\n  const canUndo = state.past.length !== 0;\r\n  const canRedo = state.future.length !== 0;\r\n  const undo = React.useCallback(() => dispatch({ type: UNDO }), []);\r\n  const redo = React.useCallback(() => dispatch({ type: REDO }), []);\r\n  const set = React.useCallback(\r\n    (newPresent) => dispatch({ type: SET, newPresent }),\r\n    []\r\n  );\r\n  const reset = React.useCallback(\r\n    (newPresent) => dispatch({ type: RESET, newPresent }),\r\n    []\r\n  );\r\n  return [state, { set, reset, undo, redo, canUndo, canRedo }];\r\n}\r\n","import Cube from '../Cube/Cube'\r\nimport React, {useEffect, useRef, useState} from 'react'\r\nimport { useFrame } from 'react-three-fiber'\r\nimport * as THREE from 'three'\r\nimport useRotation from './useRotation'\r\nimport useDrag from './useDrag'\r\nimport {maxKey, randomNum} from './hooks'\r\nimport useHistory from './useHistory'\r\n\r\nconst dimensions = 3;\r\n\r\nconst RubikCube = ({blockRubikCubeRotation, onShuffle, onUndo, onRedo, onSolve}) => {\r\n  const [rotateAxis, initialCubeClicked, direction, dispatch] = useRotation()\r\n  const [state, { set, reset, undo, redo, canUndo, canRedo }] = useHistory([])\r\n  \r\n  const [allCubes, setAllCubes] = useState([])\r\n  const [controlRotation, setControlRotation] = useState(0)\r\n  const [movementQueue, setMovementQueue] = useState([])\r\n\r\n  const rubikCube = useRef()\r\n  const pivot = useRef()\r\n  \r\n  //RUBIK CUBE CREATION\r\n  useEffect(()=> {\r\n    let assistCube = []\r\n    for (let i = 0; i < dimensions; i++) {\r\n      for (let j = 0; j < dimensions; j++) {\r\n        for (let k = 0; k < dimensions; k++) {\r\n          const x = (i - 1) * 1,\r\n            y = (j - 1) * 1,\r\n            z = (k - 1) * 1;\r\n          assistCube.push(\r\n            <Cube\r\n              key={assistCube.length}\r\n              position={{'x': x, 'y': y, 'z': z}}\r\n            />\r\n          )\r\n        }\r\n      }\r\n    }\r\n    setAllCubes(assistCube)\r\n  },[])\r\n\r\n  //On click on any cube\r\n  const onStart = (e) => {\r\n    if(!activeDrag && !rotateAxis){\r\n    //looks for the face coordinate with higher abs value in the intersection point, that is the clicked face, dispatches the start of movement with the clicked face axis, the clicked cube and the face axis side(positive or negative)\r\n    let faceClicked = maxKey(e.intersections[0].point)\r\n    dispatch({\r\n      type: \"start_movement_point\",\r\n      cubeFaceClicked: faceClicked,\r\n      initialCubeClicked: e.intersections[0].point,\r\n      rubikCubeSide: Math.sign(e.intersections[0].point[faceClicked])\r\n    });\r\n    }\r\n  };\r\n  //On drag after click\r\n  const onDrag = (e) => {\r\n    //if in movement and if it hasn't rotate already PI/2\r\n    if(activeDrag && Math.abs(controlRotation) < Math.PI / 2){\r\n      dispatch({type: \"trace_movement_destination\", finalCube: e.intersections[0].point})\r\n      //Dragging rotation will be performed if there is an axis to rotate and the initial and final points don't match\r\n      if(initialCubeClicked !== e.intersections[0].point && rotateAxis){\r\n          visualMove(0.025)\r\n      }\r\n    } \r\n  }\r\n\r\n  //Custom hook that uses previous defined functions\r\n  const [activeDrag, bindDrag] = useDrag(onStart, onDrag, null, blockRubikCubeRotation)\r\n\r\n  //Animation after click release\r\n  useFrame(()=> { \r\n    if(rotateAxis && !activeDrag){\r\n      if(Math.abs(controlRotation) < Math.PI / 2){\r\n        visualMove(0.125) \r\n      } else { // If the rotation exceeds PI/2 adjust it, dispatch the end of movement and reset values\r\n        visualMove(-1*(Math.abs(controlRotation)-Math.PI /2))\r\n        if(movementQueue.length !== 0){ //If there are movements stored remove the first one, this is for automated rotations\r\n          setMovementQueue(movementQueue => movementQueue.slice(1, movementQueue.length))\r\n        } else {\r\n          set([initialCubeClicked, rotateAxis, direction])\r\n        }\r\n        dispatch({type:'finish_movement'})\r\n        pivot.current.rotation[rotateAxis] = 0\r\n        setControlRotation(0)\r\n\r\n      }\r\n    }\r\n  })\r\n\r\n  //Funcion that performs the visual movement\r\n  function visualMove(rotation){\r\n    pivot.current.rotation[rotateAxis] = direction * rotation\r\n    pivot.current.updateMatrixWorld()\r\n    setControlRotation(controlRotation => controlRotation + (direction * rotation))\r\n    allCubes.forEach((cube,i) => {\r\n      if(Math.round(rubikCube.current.children[i].getWorldPosition(new THREE.Vector3())[rotateAxis]) === Math.round(initialCubeClicked[rotateAxis])){\r\n        rubikCube.current.children[i].applyMatrix4(pivot.current.matrixWorld)\r\n      }\r\n    })\r\n  }\r\n\r\n  /////////////////////////////////Automated movements\r\n  //Shuffles the cube randomly\r\n  onShuffle(() => {\r\n    let movements = []\r\n    for (let i = 0; i <= randomNum(20,40); i++) {\r\n      let movement = [\r\n        allCubes[randomNum(0, allCubes.length - 1)].props.position,\r\n        [\"x\", \"y\", \"z\"][randomNum(0, 2)],\r\n        Math.round(Math.random()) ? 1 : -1,\r\n      ]\r\n      movements.push(movement)\r\n      set(movement)\r\n    }\r\n    setMovementQueue(movements)\r\n  });\r\n  //Undo movement\r\n  onUndo(()=>{\r\n    if(canUndo){\r\n      //Is necessary to reverse the direction\r\n      setMovementQueue([[state.present[0], state.present[1], state.present[2]*-1 ]])\r\n      undo()\r\n    }\r\n  })\r\n  //Redo movement\r\n  onRedo(()=>{\r\n    if(canRedo){\r\n      setMovementQueue([state.future[0]])\r\n      redo()\r\n    }\r\n  })\r\n  //Solve cube\r\n  onSolve(()=>{\r\n    if(canUndo){\r\n      let past = state.past.map(movement => { //Change all directions\r\n        return movement.map((val,i) => {\r\n          return i === 2 ? val*=-1 : val\r\n        })\r\n      })\r\n      let present = [state.present[0], state.present[1], state.present[2]*-1 ] //Change present direction\r\n      setMovementQueue([present].concat(past.reverse().slice(0, past.length - 1))) //Concatenate the present with the reversed past minus last index, that one is always empty because of history hook\r\n      reset([])\r\n    }\r\n  })\r\n  //This effect handles the automated rotations, when state movementQueue changes, it gets executed\r\n  useEffect(()=> {\r\n    if(movementQueue.length !== 0){\r\n      let movement = movementQueue[0]\r\n      dispatch({\r\n        type: \"auto_rotate\",\r\n        initialCubeClicked: movement[0],\r\n        rotateAxis: movement[1],\r\n        direction: movement[2],\r\n      });\r\n    }\r\n  },[movementQueue])\r\n\r\n\r\n  return (\r\n    <>\r\n      <group rotation={[0, 0, 0]} name={\"group\"} {...bindDrag} ref={rubikCube}>\r\n        {allCubes}\r\n      </group>\r\n      <group ref={pivot} position={[0, 0, 0]} name={\"pivot\"} />\r\n    </>\r\n  );\r\n}\r\n\r\nexport default RubikCube","import React from 'react'\r\n\r\nconst Lights = () => {\r\n  return (\r\n    <group>\r\n      <hemisphereLight skyColor={'#ffffff'} groundColor={'#ffffff'} intensity={.7} />\r\n      {/* <spotLight intensity={.5} castShadow position={[0, 100, 0]} angle={0.15} penumbra={1} /> */}\r\n      {/* <pointLight intensity={1.5} color={'#fb2a92'} castShadow position={[0, 1, -10]} /> */}\r\n      {/* <directionalLight intensity={2} color={'#fb2a92'} position={[0,10,-10]} /> */}\r\n      {/* <rectAreaLight intensity={2} color={'#fb2a92'} position={[0,10,0]} width={400} height={400} rotation={[-Math.PI / 2, 0, 0]}/> */}\r\n    </group>\r\n\r\n  )\r\n}\r\n\r\nexport default Lights","import React, {useState, useLayoutEffect} from 'react'\r\nimport {useThree, useResource, useFrame , useLoader} from 'react-three-fiber'\r\nimport {BackSide, WebGLCubeRenderTarget, CubeTextureLoader} from 'three'\r\nimport * as THREE from 'three'\r\n\r\nexport default function World() {\r\n  const { scene, gl } = useThree()\r\n  const [texture] = useLoader(CubeTextureLoader, [[\"Background/1.jpg\",\"Background/2.jpg\",\"Background/3.jpg\",\"Background/4.jpg\",\"Background/5.jpg\",\"Background/6.jpg\"]])\r\n  useLayoutEffect(() => {\r\n    texture.encoding = THREE.sRGBEncoding\r\n    const oldBg = scene.background\r\n    const oldEnv = scene.environment\r\n    scene.background = texture\r\n    scene.environment = texture\r\n    // Clean up on unmount\r\n    return () => {\r\n      scene.background = oldBg\r\n      scene.environment = oldEnv\r\n      texture.dispose()\r\n    }\r\n  }, [scene, texture])\r\n  return null\r\n}\r\n\r\n","import React, {useState, useLayoutEffect} from 'react'\r\nimport {useThree, useResource, useFrame , useLoader} from 'react-three-fiber'\r\nimport {BackSide, WebGLCubeRenderTarget, TextureLoader} from 'three'\r\n\r\n\r\nconst Environment = () => {\r\n  const camera = useResource()\r\n  const { scene, gl } = useThree()\r\n  const [cubeRenderTarget] = useState(() => new WebGLCubeRenderTarget(256))\r\n  \r\n  const texture = useLoader(TextureLoader, 'Background/4.jpg')\r\n  useFrame(() => camera.current.update(gl, scene))\r\n\r\n  //There are 2 planes, the first one, creates a mirroring effect the second is the actual ground\r\n  return (\r\n    <>\r\n    <cubeCamera ref={camera} args={[1, 1000, cubeRenderTarget]} position={[0,-7,0]}/>\r\n    <mesh visible position={[0, -5, 0]} rotation={[-Math.PI / 2, 0, 0]}>\r\n      <planeBufferGeometry args={[1024, 1024]} attach=\"geometry\"/>\r\n      <meshBasicMaterial envMap={cubeRenderTarget.texture} opacity={0.25} transparent/>\r\n    </mesh>\r\n    \r\n    <mesh visible position={[0, -6, 0]} rotation={[-Math.PI / 2, 0, 0]} >\r\n      <planeBufferGeometry args={[512, 512]} attach=\"geometry\"/>\r\n      <meshBasicMaterial\r\n        metalness={0.4}\r\n        map={texture}\r\n      />\r\n    </mesh>\r\n\r\n    </>\r\n  );\r\n};\r\n\r\nexport default Environment\r\n","import React, { useEffect, useRef, useState, Suspense }from 'react';\nimport RubikCube from './Components/RubikCube/RubikCube'\nimport * as THREE from 'three'\nimport Ligths from './Components/Ligths/Lights'\nimport World from './Components/World/World'\nimport { Canvas, useFrame, useThree, extend } from 'react-three-fiber'\nimport './App.css';\nimport Environment from './Components/Environment/Environment';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\nimport {Loader} from 'drei'\n\nextend({ OrbitControls })\n\nconst CameraControls = ({rotate}) => {\n  const {camera, gl:{domElement}} = useThree()\n  const controls = useRef()\n  \n  useFrame(() => {\n    controls.current.update()\n  })\n\n\n  return (\n    <orbitControls\n      ref={controls}\n      args={[camera, domElement]}\n      enableZoom={true}\n      enableRotate={rotate}\n      enableDamping={true}\n      dampingFactor={0.05}\n      maxDistance={12}\n      minDistance={6}\n      enablePan={false}\n    />\n  );\n}\n\nfunction App() {\n\n  const [clickOnCube, setClickOnCube] = useState(false)\n  const shuffleRef = useRef()\n  const undoRef = useRef()\n  const redoRef = useRef()\n  const solveRef = useRef()\n\n  const handleClickCube = (value) => {\n    setClickOnCube(value)\n  }\n  \n  return (\n    <>\n      <div className={'Menu'}>\n        <button onClick={() => shuffleRef && shuffleRef.current()}>\n          Shuffle\n        </button>\n        <button onClick={() => undoRef && undoRef.current()}>\n          Undo\n        </button>\n        <button onClick={() => redoRef && redoRef.current()}>\n          Redo\n        </button>\n        <button onClick={() => solveRef && solveRef.current()}>\n          Solve\n        </button>\n      </div>\n      <Canvas className={Canvas} shadowMap camera={{ position: [7, 3, 7] }}>\n        {/* <axesHelper args={[4,4,4]}/> */}\n        {/* <fog attach=\"fog\" args={['#1a033d', 5, 50]} />  */}\n        <CameraControls rotate={!clickOnCube} /> \n        <Suspense fallback={null}>\n          <RubikCube\n            onShuffle={(callback) => (shuffleRef.current = callback)}\n            onUndo={(callback) => (undoRef.current = callback)}\n            onRedo={(callback) => (redoRef.current = callback)}\n            onSolve={(callback) => (solveRef.current = callback)}\n            blockRubikCubeRotation={handleClickCube}\n          />\n          <Environment />\n          <World />\n        </Suspense>\n        <Ligths />\n      </Canvas>\n      <Loader />\n    </>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}